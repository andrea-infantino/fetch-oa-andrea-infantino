package com.fetch.fetch_oa;

import java.util.Map;
import java.util.UUID;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Pattern;

import org.springframework.stereotype.Service;

import com.fetch.fetch_oa.DTOs.Item;
import com.fetch.fetch_oa.DTOs.Receipt;

/**
 * Service to handle operations on receipts and points, and to store data.
 */
@Service
public class DataService {

    /**
     * Map to store the points associated with each receipt ID.
     * The ID is the key, and the points are the value.
     */
    private final Map<String, Integer> data = new ConcurrentHashMap<>();

    /**
     * Method to process a receipt and calculate points based on the following rules:
     * <ul>
     *  <li>One point for every alphanumeric character in the retailer name.</li>
     *  <li>50 points if the total is a round dollar amount with no cents.</li>
     *  <li>25 points if the total is a multiple of 0.25.</li>
     *  <li>5 points for every two items on the receipt.</li>
     *  <li>If the trimmed length of the item description is a multiple of 3, multiply the price by 0.2 and round up to the nearest integer. The result is the number of points earned.</li>
     *  <li>6 points if the day in the purchase date is odd.</li>
     *  <li>10 points if the time of purchase is after 2:00pm and before 4:00pm.</li>
     * </ul>
     * @param receipt The receipt object to be processed.
     * @return A unique ID for the receipt, generated by the server.
     */
    public String add(Receipt receipt) {
        int points = 0;
        
        points += receipt.getRetailer().chars()
        .filter(c -> Character.isLetterOrDigit(c))
        .count();

        double total = Double.parseDouble(receipt.getTotal());
        if (((int) total) == total) points += 50;
        if ((total * 100) % 25 == 0) points += 25;

        Item[] items = receipt.getItems();
        points += 5 * ((int) (items.length / 2));
        for (Item item : items)
            if (item.getShortDescription().trim().length() % 3 == 0)
                points += (int) Math.ceil(0.2 * Double.parseDouble(item.getPrice()));
        
        if (LocalDate.parse(receipt.getPurchaseDate()).getDayOfMonth() % 2 == 1) points += 6;

        int hour = LocalTime.parse(receipt.getPurchaseTime(), DateTimeFormatter.ofPattern("HH:mm")).getHour();
        if (hour >= 14 && hour <= 16) points += 10;

        String id = UUID.randomUUID().toString();
        data.put(id, points);
        return id;
    }

    /**
     * Method to retrieve the points associated with a given receipt ID.
     * @param id The unique ID of the receipt.
     * @return The points associated with the receipt ID.
     */
    public int get(String id) {
        return data.get(id);
    }

    /**
     * Method to validate the receipt object.
     * @param receipt The receipt object to be validated.
     * @return true if the receipt is valid, false otherwise.
     */
    public boolean checkReceipt(Receipt receipt) {
        if (receipt.getRetailer() == null || !Pattern.matches("^[\\w\\s\\-&]+$", receipt.getRetailer()))
            return false;

        try{
            LocalDate.parse(receipt.getPurchaseDate(), DateTimeFormatter.ofPattern("yyyy-MM-dd"));
            LocalTime.parse(receipt.getPurchaseTime(), DateTimeFormatter.ofPattern("HH:mm"));
        } catch (Exception e) {
            return false;
        }

        if (receipt.getTotal() == null || !Pattern.matches("^\\d+\\.\\d{2}$", receipt.getTotal()))
            return false;
        
        Item[] items = receipt.getItems();
        if (items == null || items.length == 0)
            return false;
        for (Item item : items) {
            if (item.getShortDescription() == null || !Pattern.matches("^[\\w\\s\\-]+$", item.getShortDescription()))
                return false;
            if (item.getPrice() == null || !Pattern.matches("^\\d+\\.\\d{2}$", item.getPrice()))
                return false;
        }
        
        return true;
    }

    /**
     * Method to check if the given ID is valid and exists in the data map.
     * @param id The unique ID of the receipt.
     * @return true if the ID is valid and exists, false otherwise.
     */
    public boolean checkId(String id) {
        return id != null && Pattern.matches("^\\S+$", id) && data.containsKey(id);
    }
}
